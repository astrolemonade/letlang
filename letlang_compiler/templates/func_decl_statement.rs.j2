{% if public %}pub {% endif %}mod symbol_{{symbol_name}} {
  use llcore_runtime::*;

  #[allow(non_camel_case_types)]
  {% if type_params %}
    pub struct func_{{symbol_name}} {
      {% for type_param in type_params %}
        {{type_param}}: Box<dyn Type>,
      {% endfor %}
    }
  {% else %}
    pub struct func_{{symbol_name}};
  {% endif %}

  impl Function for func_{{symbol_name}} {
    fn call(&self, context: Arc<Mutex<Context>>, args: Vec<Value>) -> FunctionContinuation {
      async fn code_block(
        co: FunctionCoroutine,
        context: Arc<Mutex<Context>>,
        args: Vec<Value>,
      ) -> Value {
        {% for call_param in call_params %}
          let paramtype_{{ call_param.name }} = {{ call_param.type_code }};
          let paramval_{{ call_param.name }} = &args[{{ loop.index0 }}];
          utils::assert_type(
            &co,
            context.clone(),
            &paramtype_{{ call_param.name }},
            &paramval_{{ call_param.name }},
            format!(
              "function param {{ call_param.name }} expects {}",
              paramtype_{{ call_param.name }}.to_string(context.clone()),
            ),
          ).await;
        {% endfor %}
        let return_type = {{ return_type }};

        {% for expression in body %}
          {% if not loop.last %}
            {{ expression }};
          {% else %}
            let result = {{ expression }};

            utils::assert_type(
              &co,
              context.clone(),
              &return_type,
              &result,
              format!(
                "function {{ symbol_name }} should return {}",
                return_type.to_string(context.clone()),
              ),
            ).await;

            result
          {% endif %}
        {% endfor %}
      }

      FunctionContinuation::new_boxed(|co| code_block(co, context, args))
    }
  }
}
